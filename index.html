<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Fibo Drill - Manual Submit</title>
  <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* 1. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ */
    body { 
        background: #222; margin: 0; padding: 0; 
        font-family: 'Sarabun', sans-serif; 
        width: 100vw; height: 100vh; height: 100dvh; 
        overflow: hidden; touch-action: none;
    }
    #game-container { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #333; 
    }
    canvas { display: block; width: 100%; height: 100%; cursor: grab; touch-action: none; }
    canvas:active { cursor: grabbing; }

    /* 2. ‡πÅ‡∏ú‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° (Control Panel) */
    #control-area { 
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
        width: 90%; max-width: 450px;
        background: rgba(30,35,41,0.95); backdrop-filter: blur(10px);
        border: 1px solid #fcd535; border-radius: 20px;
        padding: 20px; z-index: 100;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        display: flex; flex-direction: column; gap: 15px; pointer-events: auto;
    }
    .question-text { font-size: 16px; font-weight: bold; color: #fff; margin: 0; text-align: center; }

    /* ‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á */
    .btn-group { display: flex; gap: 10px; width: 100%; }

    /* ‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ */
    .action-btn {
        flex: 1; padding: 12px; border-radius: 12px; font-size: 16px; font-weight: bold;
        cursor: pointer; border: none; display: flex; align-items: center; justify-content: center; gap: 5px;
        transition: 0.2s;
    }
    
    /* ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏≤‡∏î (‡∏™‡∏µ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á) */
    .btn-draw { background: #333; color: #fcd535; border: 2px solid #fcd535; }
    .btn-draw.active { background: #fcd535; color: #000; box-shadow: 0 0 15px rgba(252, 213, 53, 0.5); animation: pulse 1.5s infinite; }
    
    /* ‡∏õ‡∏∏‡πà‡∏°‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö (‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß) */
    .btn-submit { background: #28a745; color: white; box-shadow: 0 4px 10px rgba(40, 167, 69, 0.4); }
    .btn-submit:active { transform: scale(0.95); }

    /* ‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏ö (‡∏™‡∏µ‡πÅ‡∏î‡∏á) */
    .btn-delete { background: #dc3545; color: white; flex: 0.5; } /* ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πà‡∏≠‡∏¢ */
    .btn-delete:active { transform: scale(0.95); }

    @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.02);} 100% {transform: scale(1);} }

    /* ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏£‡∏¥‡∏° (‡∏°‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô) */
    .reset-btn { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.6); color: white; border: 1px solid #555; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; z-index: 200; }
    .reverse-btn { position: absolute; top: 15px; right: 120px; background: rgba(255, 193, 7, 0.2); color: #ffc107; border: 1px solid #ffc107; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; z-index: 200; }

    /* Modal ‡πÅ‡∏à‡πâ‡∏á‡∏ú‡∏• */
    #msg-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px 40px; border-radius: 12px; text-align: center; display: none; z-index: 300; border: 2px solid #fff; }
    .msg-success { border-color: #28a745 !important; color: #28a745; }
    .msg-fail { border-color: #dc3545 !important; color: #dc3545; }
  </style>
</head>
<body>

<div id="game-container">
    <canvas id="quizCanvas"></canvas>
    <button class="reverse-btn" onclick="toggleReverse()">üîÅ ‡∏Å‡∏•‡∏±‡∏ö‡∏î‡πâ‡∏≤‡∏ô</button>
    <button class="reset-btn" onclick="resetView()">üîÑ Reset View</button>
</div>

<div id="control-area">
    <div id="questionText" class="question-text">Loading...</div>
    
    <div id="group-start" class="btn-group">
        <button id="btnDraw" class="action-btn btn-draw" onclick="activateDrawTool()">
            ‚úèÔ∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏µ Fibo
        </button>
    </div>

    <div id="group-action" class="btn-group" style="display: none;">
        <button class="action-btn btn-delete" onclick="deleteLine()">
            üóëÔ∏è ‡∏•‡∏ö
        </button>
        <button class="action-btn btn-submit" onclick="checkAnswer()">
            ‚úÖ ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö
        </button>
    </div>
</div>

<div id="msg-modal"><h1 id="msg-text" style="margin:0; font-size:32px;"></h1></div>

<script>
// 1. üìÇ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏à‡∏ó‡∏¢‡πå
const steps = [
  {
    "image": "fibo1.png", 
    "question": "‡∏à‡∏á‡∏ï‡∏µ Fibo ‡∏Ç‡∏≤‡∏•‡∏á (Swing High -> Low)",
    "answer": { "x1": 200, "y1": 100, "x2": 400, "y2": 500 }, 
    "type": "down" 
  }
];

// 2. Engine Initialization
const canvas = document.getElementById('quizCanvas');
const ctx = canvas.getContext('2d');
const bgImage = new Image();
const container = document.getElementById('game-container');

let currentStepIdx = 0;
let currentMode = 'hand'; 
let isFiboReversed = false;

// Camera
let camera = { x: 0, y: 0, z: 1 };
let isPanning = false;
let startPanCoord = { x: 0, y: 0 };

// Drawing
let isDrawing = false;
let userLine = null; 
let startDrawCoord = { x: 0, y: 0 }; 

// Touch & Crosshair
let initialPinchDist = null;
let lastCameraZ = 1;
let pinchCenterWorld = { x:0, y:0 };
let isCrosshairActive = false; 
let crosshairPos = { x: 0, y: 0 }; 

window.onload = function() { loadStep(); };
window.addEventListener('resize', () => { fitToScreen(); draw(); });

function loadStep() {
    if(currentStepIdx >= steps.length) { alert("üéâ ‡∏à‡∏ö‡πÄ‡∏Å‡∏°!"); location.href='dashboard.html'; return; }
    const s = steps[currentStepIdx];
    document.getElementById('questionText').innerText = `‡∏Ç‡πâ‡∏≠ ${currentStepIdx + 1}: ${s.question}`;
    
    deleteLine(); // ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏Å‡πà‡∏≤
    isFiboReversed = false;
    
    bgImage.src = s.image;
    bgImage.onload = function() { resetView(); }
}

// ==========================================
// üõ†Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏õ‡∏∏‡πà‡∏° (UI State Manager)
// ==========================================
function updateButtons() {
    const groupStart = document.getElementById('group-start');
    const groupAction = document.getElementById('group-action');
    const btnDraw = document.getElementById('btnDraw');

    if (userLine) {
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß -> ‡πÇ‡∏ä‡∏ß‡πå‡∏õ‡∏∏‡πà‡∏° ‡∏•‡∏ö/‡∏™‡πà‡∏á
        groupStart.style.display = 'none';
        groupAction.style.display = 'flex';
        currentMode = 'hand'; // ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏°‡∏∑‡∏≠‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
    } else {
        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô -> ‡πÇ‡∏ä‡∏ß‡πå‡∏õ‡∏∏‡πà‡∏° ‡∏ß‡∏≤‡∏î
        groupStart.style.display = 'flex';
        groupAction.style.display = 'none';
        
        // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏°‡∏ß‡∏≤‡∏î
        if (currentMode === 'pen') {
            btnDraw.className = 'action-btn btn-draw active';
            btnDraw.innerHTML = 'üéØ ‡∏ß‡∏≤‡∏î‡∏ü‡∏¥‡πÇ‡∏ö‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö!';
        } else {
            btnDraw.className = 'action-btn btn-draw';
            btnDraw.innerHTML = '‚úèÔ∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏µ Fibo';
        }
    }
}

function activateDrawTool() {
    currentMode = 'pen';
    updateButtons();
}

function deleteLine() {
    userLine = null;
    currentMode = 'hand';
    updateButtons();
    draw();
}

function toggleReverse() { isFiboReversed = !isFiboReversed; draw(); }

function fitToScreen() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if(!bgImage.complete) return;
    const scale = Math.min(canvas.width/bgImage.naturalWidth, canvas.height/bgImage.naturalHeight) * 0.95;
    camera.z = scale;
    camera.x = (canvas.width - bgImage.naturalWidth * scale) / 2;
    camera.y = (canvas.height - bgImage.naturalHeight * scale) / 2;
}
function resetView() { fitToScreen(); draw(); }
function getWorldPos(clientX, clientY) {
    return { x: (clientX - camera.x) / camera.z, y: (clientY - camera.y) / camera.z };
}

// ==========================================
// üñêÔ∏è‚úèÔ∏è Input Handling
// ==========================================
container.addEventListener('touchstart', handleStart, { passive: false });
container.addEventListener('touchmove', handleMove, { passive: false });
container.addEventListener('touchend', handleEnd);
container.addEventListener('mousedown', handleStart);
container.addEventListener('mousemove', handleMove);
container.addEventListener('mouseup', handleEnd);
container.addEventListener('wheel', (e) => { e.preventDefault(); });

function handleStart(e) {
    e.preventDefault(); 
    const touches = e.touches;
    const clientX = touches ? touches[0].clientX : e.clientX;
    const clientY = touches ? touches[0].clientY : e.clientY;

    if (touches && touches.length === 1 && currentMode === 'pen') {
        isCrosshairActive = true;
        crosshairPos = { x: clientX, y: clientY };
        draw();
    }

    if (touches && touches.length === 2) {
        isPanning = false; isDrawing = false;
        initialPinchDist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
        lastCameraZ = camera.z;
        const midX = (touches[0].clientX + touches[1].clientX) / 2;
        const midY = (touches[0].clientY + touches[1].clientY) / 2;
        pinchCenterWorld = getWorldPos(midX, midY);
    } else if (currentMode === 'hand') {
        isPanning = true;
        startPanCoord = { x: clientX - camera.x, y: clientY - camera.y };
    } else if (currentMode === 'pen') {
        isDrawing = true;
        startDrawCoord = getWorldPos(clientX, clientY);
        userLine = { x1: startDrawCoord.x, y1: startDrawCoord.y, x2: startDrawCoord.x, y2: startDrawCoord.y };
        draw();
    }
}

function handleMove(e) {
    e.preventDefault();
    const touches = e.touches;
    const clientX = touches ? touches[0].clientX : e.clientX;
    const clientY = touches ? touches[0].clientY : e.clientY;

    if (touches && touches.length === 2 && initialPinchDist) {
        const dist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
        const newZoom = lastCameraZ * (dist / initialPinchDist);
        if (newZoom > 0.1 && newZoom < 10) {
            camera.z = newZoom;
            const midX = (touches[0].clientX + touches[1].clientX) / 2;
            const midY = (touches[0].clientY + touches[1].clientY) / 2;
            camera.x = midX - pinchCenterWorld.x * camera.z;
            camera.y = midY - pinchCenterWorld.y * camera.z;
            draw();
        }
    } else if (isPanning) {
        camera.x = clientX - startPanCoord.x;
        camera.y = clientY - startPanCoord.y;
        draw();
    } else if (isDrawing) {
        const currWorld = getWorldPos(clientX, clientY);
        userLine.x2 = currWorld.x;
        userLine.y2 = currWorld.y;
        if(touches) { isCrosshairActive = true; crosshairPos = { x: clientX, y: clientY }; }
        draw();
    } else if (!touches && !isPanning) {
        isCrosshairActive = true; crosshairPos = { x: clientX, y: clientY }; draw();
    }
}

function handleEnd(e) {
    if (e.touches) isCrosshairActive = false; 

    if(isDrawing) {
        // üî• ‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏ß‡∏à!
        isDrawing = false;
        
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡πâ‡∏°‡∏µ "‡∏™‡πà‡∏á" ‡∏Å‡∏±‡∏ö "‡∏•‡∏ö" ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤
        updateButtons();
    }
    
    isPanning = false;
    if (e.touches && e.touches.length < 2) initialPinchDist = null;
    draw();
}

// ==========================================
// üé® Rendering
// ==========================================
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(camera.x, camera.y);
    ctx.scale(camera.z, camera.z);

    if(bgImage.complete && bgImage.naturalWidth > 0) ctx.drawImage(bgImage, 0, 0); 

    if(userLine) {
        const s = steps[currentStepIdx];
        const color = s.type === 'down' ? '#dc3545' : '#28a745';
        ctx.beginPath(); ctx.moveTo(userLine.x1, userLine.y1); ctx.lineTo(userLine.x2, userLine.y2);
        ctx.lineWidth = 4 / camera.z; ctx.strokeStyle = color; ctx.stroke();
        const radius = 8 / camera.z;
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(userLine.x1, userLine.y1, radius, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(userLine.x2, userLine.y2, radius, 0, Math.PI*2); ctx.fill();
        drawFiboLevels(userLine, color);
    }
    ctx.restore(); 

    if (isCrosshairActive) drawCrosshair();
}

function drawCrosshair() {
    const x = crosshairPos.x;
    const y = crosshairPos.y;
    ctx.beginPath(); ctx.setLineDash([6, 4]); ctx.lineWidth = 1.5;
    ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; 
    ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
    ctx.strokeStyle = "rgba(50, 50, 50, 0.9)"; 
    ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
    ctx.setLineDash([]); 
    ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fillStyle = "rgba(255, 215, 0, 0.8)"; 
    ctx.strokeStyle = "black"; ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
}

function drawFiboLevels(line, color) {
    const levels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1, 1.272, 1.618, 2.618, 4.236];
    const worldRightEdge = (canvas.width - camera.x) / camera.z; 
    let p100, p0;
    if (!isFiboReversed) { p100 = {x: line.x1, y: line.y1}; p0 = {x: line.x2, y: line.y2}; } 
    else { p0 = {x: line.x1, y: line.y1}; p100 = {x: line.x2, y: line.y2}; }
    const dx = p100.x - p0.x; const dy = p100.y - p0.y;
    levels.forEach(lvl => {
        const my = p0.y + (dy * lvl);
        const startX = Math.min(line.x1, line.x2);
        ctx.beginPath(); 
        if (lvl === 0 || lvl === 1 || lvl === 1.618) { ctx.setLineDash([]); ctx.lineWidth = 1.5 / camera.z; } 
        else { ctx.setLineDash([4/camera.z, 4/camera.z]); ctx.lineWidth = 1 / camera.z; }
        ctx.strokeStyle = color;
        ctx.moveTo(startX, my); ctx.lineTo(worldRightEdge + 5000, my); ctx.stroke();
        ctx.fillStyle = color; ctx.font = `bold ${12/camera.z}px Arial`; ctx.textAlign = "right"; ctx.textBaseline = "bottom";
        let text = (lvl * 100).toFixed(1); if (text.endsWith('.0')) text = text.replace('.0', ''); 
        ctx.fillText(`${text}%`, startX - (5/camera.z), my - (2/camera.z));
    });
    ctx.setLineDash([]); 
}

// 3. ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° Submit ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
function checkAnswer() {
    if(!userLine) return;
    const ans = steps[currentStepIdx].answer;
    const tolerance = 50; 
    const distStart = Math.hypot(userLine.x1 - ans.x1, userLine.y1 - ans.y1);
    const distEnd = Math.hypot(userLine.x2 - ans.x2, userLine.y2 - ans.y2);
    const distStartRev = Math.hypot(userLine.x1 - ans.x2, userLine.y1 - ans.y2);
    const distEndRev = Math.hypot(userLine.x2 - ans.x1, userLine.y2 - ans.y1);

    if ((distStart < tolerance && distEnd < tolerance) || (distStartRev < tolerance && distEndRev < tolerance)) {
        showMsg("‚úÖ ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á!", true);
        setTimeout(() => { currentStepIdx++; loadStep(); hideMsg(); }, 1000);
    } else { showMsg("‚ùå ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö!", false); setTimeout(hideMsg, 1000); }
}
function showMsg(text, isSuccess) {
    const m = document.getElementById('msg-modal');
    m.style.display = 'block'; m.className = isSuccess ? 'msg-success' : 'msg-fail';
    document.getElementById('msg-text').innerText = text;
}
function hideMsg() { document.getElementById('msg-modal').style.display = 'none'; }
</script>
</body>
</html>
